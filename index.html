<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NeuroFlux | Advanced Healing</title>
  <style>
    :root {
      --primary: #6e48aa;
      --secondary: #9d50bb;
      --dark: #1a1a2e;
      --light: #f8f9fa;
      --success: #4cc9f0;
      --warning: #f72585;
      --info: #4895ef;
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: var(--light);
      line-height: 1.6;
      overflow: hidden;
    }
    
    #app {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    /* Visuals layer - full screen behind content */
    #visuals-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
      pointer-events: none;
    }
    
    #visuals {
      width: 100%;
      height: 100%;
    }
    
    /* Content layer */
    #content {
      position: relative;
      z-index: 10;
      display: flex;
      flex-direction: column;
      height: 100vh;
      background-color: rgba(10, 10, 20, 0.2);
      backdrop-filter: blur(5px);
      overflow-y: auto;
    }
    
    header {
      padding: 1rem;
      text-align: center;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color: white;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
    
    h1 {
      font-size: 1.8rem;
      margin-bottom: 0.5rem;
    }
    
    .tagline {
      font-size: 0.9rem;
      opacity: 0.9;
    }
    
    .main-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 1rem;
      gap: 1rem;
    }
    
    .section {
      background: rgba(26, 26, 46, 0.8);
      border-radius: 12px;
      padding: 1rem;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
    
    .section-title {
      font-size: 1.2rem;
      margin-bottom: 0.8rem;
      color: var(--success);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .mood-wheel {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }
    
    .wheel-container {
      position: relative;
      width: 250px;
      height: 250px;
      margin: 0 auto;
    }
    
    .wheel {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      position: relative;
      overflow: hidden;
      cursor: pointer;
      transition: transform 0.3s ease;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }
    
    .wheel:hover {
      transform: scale(1.05);
    }
    
    .wheel-section {
      position: absolute;
      width: 50%;
      height: 50%;
      transform-origin: 100% 100%;
      clip-path: polygon(0 0, 100% 0, 100% 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      transition: all 0.2s ease;
    }
    
    .wheel-section:hover {
      filter: brightness(1.1);
    }
    
    .wheel-center {
      position: absolute;
      width: 30%;
      height: 30%;
      background: white;
      border-radius: 50%;
      top: 35%;
      left: 35%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: var(--dark);
      box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2);
      cursor: pointer;
      z-index: 2;
    }
    
    .intensity-slider {
      width: 100%;
      max-width: 300px;
      margin: 1rem auto;
    }
    
    .slider-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
    }
    
    input[type="range"] {
      width: 100%;
      height: 8px;
      -webkit-appearance: none;
      background: linear-gradient(to right, var(--primary), var(--secondary));
      border-radius: 4px;
      outline: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    .quick-relief-btn {
      background: linear-gradient(135deg, var(--warning), #b5179e);
      color: white;
      border: none;
      padding: 0.8rem 1.5rem;
      border-radius: 50px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(247, 37, 133, 0.3);
      margin-top: 0.5rem;
    }
    
    .quick-relief-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(247, 37, 133, 0.4);
    }
    
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-top: 1rem;
    }
    
    .control-group {
      flex: 1;
      min-width: 150px;
    }
    
    select, button {
      width: 100%;
      padding: 0.6rem;
      border-radius: 6px;
      border: none;
      background-color: rgba(255, 255, 255, 0.1);
      color: white;
      margin-top: 0.5rem;
      cursor: pointer;
    }
    
    button {
      background: linear-gradient(135deg, var(--info), var(--primary));
      font-weight: bold;
      transition: all 0.2s ease;
    }
    
    button:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }
    
    .preset-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.8rem;
      margin-top: 1rem;
    }
    
    .preset-btn {
      padding: 0.6rem;
      border-radius: 6px;
      font-size: 0.8rem;
      text-align: center;
    }
    
    .session-timer {
      font-size: 2rem;
      text-align: center;
      margin: 1rem 0;
      font-family: monospace;
    }
    
    .journal-entry {
      width: 100%;
      min-height: 100px;
      padding: 0.8rem;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background-color: rgba(0, 0, 0, 0.3);
      color: white;
      resize: vertical;
      margin-top: 0.5rem;
    }
    
    .chart-container {
      width: 100%;
      height: 200px;
      margin-top: 1rem;
    }
    
    .hidden {
      display: none !important;
    }
    
    .active-session-controls {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-top: 1rem;
    }
    
    .stop-btn {
      background: linear-gradient(135deg, #f72585, #b5179e);
    }
    
    .tab-container {
      display: flex;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      margin-bottom: 1rem;
    }
    
    .tab {
      padding: 0.5rem 1rem;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.2s ease;
    }
    
    .tab.active {
      border-bottom: 2px solid var(--success);
      color: var(--success);
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .history-item {
      background: rgba(255, 255, 255, 0.05);
      padding: 0.8rem;
      border-radius: 8px;
      margin-bottom: 0.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .history-item-date {
      font-size: 0.8rem;
      opacity: 0.7;
    }
    
    .history-item-mood {
      font-weight: bold;
      color: var(--info);
    }
    
    .clear-history {
      background: rgba(247, 37, 133, 0.2);
      color: var(--warning);
      border: 1px solid var(--warning);
      margin-top: 1rem;
    }
    
    .reminder-settings {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    
    .reminder-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    input[type="time"] {
      padding: 0.4rem;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(0, 0, 0, 0.3);
      color: white;
    }
    
    /* Enhanced visual controls */
    .visual-controls {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
    }
    
    .visual-intensity {
      flex: 1;
    }
    
    /* Audio visualization */
    .audio-bars {
      display: flex;
      height: 60px;
      align-items: flex-end;
      gap: 2px;
      margin-top: 1rem;
    }
    
    .audio-bar {
      flex: 1;
      background: linear-gradient(to top, var(--info), var(--primary));
      min-width: 3px;
      border-radius: 2px;
      transition: height 0.1s ease;
    }
    
    /* Full-screen toggle */
    .fullscreen-btn {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      z-index: 100;
      background: rgba(0,0,0,0.5);
      border: none;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    
    @media (max-width: 768px) {
      .wheel-container {
        width: 200px;
        height: 200px;
      }
      
      .controls {
        flex-direction: column;
      }
      
      .preset-buttons {
        grid-template-columns: 1fr 1fr;
      }
      
      .visual-controls {
        flex-direction: column;
      }
    }
    
    /* Animation for quick relief button */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    .pulse {
      animation: pulse 1.5s infinite;
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Visuals layer (full screen) -->
    <div id="visuals-container">
      <canvas id="visuals"></canvas>
    </div>
    
    <!-- Content layer -->
    <div id="content">
      <header>
        <h1>NeuroFlux</h1>
        <p class="tagline">Advanced Audio-Visual Healing</p>
      </header>
      
      <div class="main-container">
        <div class="section" id="mood-selector">
          <h2 class="section-title">Select Your Current State</h2>
          <div class="mood-wheel">
            <div class="wheel-container">
              <div class="wheel" id="wheel">
                <div class="wheel-section" data-mood="stress" style="background: #ff6b6b; transform: rotate(0deg);">
                  <span>Stress</span>
                </div>
                <div class="wheel-section" data-mood="anxiety" style="background: #ff9e2d; transform: rotate(72deg);">
                  <span>Anxiety</span>
                </div>
                <div class="wheel-section" data-mood="sadness" style="background: #4cc9f0; transform: rotate(144deg);">
                  <span>Sadness</span>
                </div>
                <div class="wheel-section" data-mood="anger" style="background: #f72585; transform: rotate(216deg);">
                  <span>Anger</span>
                </div>
                <div class="wheel-section" data-mood="fatigue" style="background: #7209b7; transform: rotate(288deg);">
                  <span>Fatigue</span>
                </div>
                <div class="wheel-center" id="wheel-center">
                  Select
                </div>
              </div>
            </div>
            
            <div class="intensity-slider">
              <div class="slider-label">
                <span>Intensity: </span>
                <span id="intensity-value">5</span>
              </div>
              <input type="range" id="intensity-slider" min="1" max="10" value="5">
            </div>
            
            <button id="quick-relief" class="quick-relief-btn">Quick 5-Minute Relief</button>
          </div>
        </div>
        
        <div class="section hidden" id="active-session">
          <h2 class="section-title" id="session-title">Session in Progress</h2>
          <div class="session-timer" id="session-timer">05:00</div>
          
          <div class="controls">
            <div class="control-group">
              <label for="binaural-type">Binaural Type</label>
              <select id="binaural-type">
                <option value="theta">Theta (4-8Hz) - Deep Relaxation</option>
                <option value="alpha">Alpha (8-12Hz) - Calm Focus</option>
                <option value="beta">Beta (12-30Hz) - Active Mind</option>
                <option value="gamma">Gamma (30-100Hz) - Peak Cognition</option>
                <option value="delta">Delta (0.5-4Hz) - Deep Sleep</option>
              </select>
            </div>
            
            <div class="control-group">
              <label for="soundscape">8D Soundscape</label>
              <select id="soundscape">
                <option value="none">None</option>
                <option value="cosmic">Cosmic Journey</option>
                <option value="forest">Enchanted Forest</option>
                <option value="ocean">Ocean Depth</option>
                <option value="temple">Sacred Temple</option>
              </select>
            </div>
          </div>
          
          <div class="visual-controls">
            <div class="control-group visual-intensity">
              <label for="visual-intensity">Visual Intensity</label>
              <input type="range" id="visual-intensity" min="1" max="10" value="5">
            </div>
            
            <div class="control-group">
              <label for="visual-theme">Theme</label>
              <select id="visual-theme">
                <option value="nebula">Cosmic Nebula</option>
                <option value="fluid">Liquid Energy</option>
                <option value="particles">Quantum Particles</option>
                <option value="fractal">Infinite Fractal</option>
              </select>
            </div>
          </div>
          
          <div class="audio-bars" id="audio-bars">
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
          </div>
          
          <div class="active-session-controls">
            <button id="pause-btn">Pause</button>
            <button id="stop-btn" class="stop-btn">End Session</button>
          </div>
        </div>
        
        <div class="section">
          <h2 class="section-title">Preset Sessions</h2>
          <div class="preset-buttons">
            <button class="preset-btn" data-preset="panic">Panic Reset</button>
            <button class="preset-btn" data-preset="focus">Deep Focus</button>
            <button class="preset-btn" data-preset="creative">Creative Flow</button>
            <button class="preset-btn" data-preset="grief">Grief Release</button>
            <button class="preset-btn" data-preset="sleep">Sleep Aid</button>
          </div>
        </div>
        
        <div class="section">
          <div class="tab-container">
            <div class="tab active" data-tab="journal">Journal</div>
            <div class="tab" data-tab="progress">Progress</div>
            <div class="tab" data-tab="history">History</div>
            <div class="tab" data-tab="settings">Settings</div>
          </div>
          
          <div class="tab-content active" id="journal-tab">
            <label for="journal-entry">Session Reflection</label>
            <textarea id="journal-entry" class="journal-entry" placeholder="What came up for you during this session?"></textarea>
            <button id="save-journal">Save Reflection</button>
          </div>
          
          <div class="tab-content" id="progress-tab">
            <div class="chart-container">
              <canvas id="progress-chart"></canvas>
            </div>
          </div>
          
          <div class="tab-content" id="history-tab">
            <div id="history-list"></div>
            <button id="clear-history" class="clear-history">Clear History</button>
          </div>
          
          <div class="tab-content" id="settings-tab">
            <h3>Reminders</h3>
            <div class="reminder-settings">
              <div class="reminder-item">
                <input type="checkbox" id="morning-reminder">
                <label for="morning-reminder">Morning Reset</label>
                <input type="time" id="morning-time" value="08:00">
              </div>
              <div class="reminder-item">
                <input type="checkbox" id="evening-reminder">
                <label for="evening-reminder">Evening Wind Down</label>
                <input type="time" id="evening-time" value="20:00">
              </div>
            </div>
            <button id="save-settings">Save Settings</button>
            
            <h3 style="margin-top: 1rem;">Biofeedback Mode</h3>
            <button id="biofeedback-btn">Enable Breath Detection</button>
            <div id="breath-feedback" style="margin-top: 0.5rem;"></div>
          </div>
        </div>
      </div>
    </div>
    
    <button class="fullscreen-btn" id="fullscreen-btn">⤢</button>
  </div>

  <script>
    // Enhanced Audio Engine with 8D and precise binaurals
    class AdvancedAudioEngine {
      constructor() {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.oscillators = [];
        this.gainNodes = [];
        this.panners = [];
        this.analyser = this.audioContext.createAnalyser();
        this.analyser.fftSize = 32;
        this.binauralType = 'theta';
        this.soundscape = null;
        this.soundscapeBuffer = null;
        this.isPlaying = false;
        this.lastPanUpdate = 0;
        this.panDirection = 1;
        this.panSpeed = 0.0005;
        
        // Setup audio graph
        this.merger = this.audioContext.createChannelMerger(2);
        this.merger.connect(this.analyser);
        this.analyser.connect(this.audioContext.destination);
        
        // Preload soundscapes
        this.soundscapeBuffers = {};
        this.loadSoundscapes();
      }
      
      async loadSoundscapes() {
        // Create procedural soundscapes
        const sampleRate = this.audioContext.sampleRate;
        const bufferLength = 10 * sampleRate; // 10 second loops
        
        // Cosmic Journey (ethereal pads with slow modulation)
        const cosmicBuffer = this.audioContext.createBuffer(2, bufferLength, sampleRate);
        const cosmicLeft = cosmicBuffer.getChannelData(0);
        const cosmicRight = cosmicBuffer.getChannelData(1);
        for (let i = 0; i < bufferLength; i++) {
          const t = i / sampleRate;
          cosmicLeft[i] = Math.sin(t * 110) * 0.2 * Math.sin(t * 0.3) +
                         Math.sin(t * 220.5) * 0.1 * Math.sin(t * 0.35);
          cosmicRight[i] = Math.sin(t * 111.7) * 0.2 * Math.sin(t * 0.31) +
                          Math.sin(t * 221.3) * 0.1 * Math.sin(t * 0.36);
        }
        this.soundscapeBuffers.cosmic = cosmicBuffer;
        
        // Enchanted Forest (nature sounds with wind)
        const forestBuffer = this.audioContext.createBuffer(2, bufferLength, sampleRate);
        const forestLeft = forestBuffer.getChannelData(0);
        const forestRight = forestBuffer.getChannelData(1);
        let windPhase = 0;
        for (let i = 0; i < bufferLength; i++) {
          const t = i / sampleRate;
          // Wind
          windPhase += 0.0001 * (1 + Math.sin(t * 0.2));
          const wind = Math.random() * 0.1 * Math.sin(windPhase);
          
          // Birds and leaves
          const birdChirp = Math.random() > 0.995 ? (Math.random() * 0.3) : 0;
          const leafRustle = Math.random() > 0.99 ? (Math.random() * 0.2) : 0;
          
          forestLeft[i] = wind * 0.7 + birdChirp * 0.3 + leafRustle * 0.5;
          forestRight[i] = wind * 0.3 + birdChirp * 0.7 + leafRustle * 0.5;
        }
        this.soundscapeBuffers.forest = forestBuffer;
        
        // Ocean Depth (deep waves with bubbles)
        const oceanBuffer = this.audioContext.createBuffer(2, bufferLength, sampleRate);
        const oceanLeft = oceanBuffer.getChannelData(0);
        const oceanRight = oceanBuffer.getChannelData(1);
        let wavePhase = 0;
        for (let i = 0; i < bufferLength; i++) {
          const t = i / sampleRate;
          // Waves
          wavePhase += 0.0005;
          const wave = Math.sin(wavePhase) * 0.3 * Math.sin(t * 0.5);
          
          // Bubbles
          const bubble = Math.random() > 0.99 ? (Math.random() * 0.2) : 0;
          
          oceanLeft[i] = wave * 0.6 + bubble * 0.4;
          oceanRight[i] = wave * 0.4 + bubble * 0.6;
        }
        this.soundscapeBuffers.ocean = oceanBuffer;
        
        // Sacred Temple (singing bowls with harmonics)
        const templeBuffer = this.audioContext.createBuffer(2, bufferLength, sampleRate);
        const templeLeft = templeBuffer.getChannelData(0);
        const templeRight = templeBuffer.getChannelData(1);
        let bowlPhase = 0;
        let decay = 0;
        for (let i = 0; i < bufferLength; i++) {
          const t = i / sampleRate;
          if (Math.random() > 0.999) {
            bowlPhase = 0;
            decay = 1.0;
          }
          
          if (decay > 0) {
            bowlPhase += 0.0005;
            decay *= 0.9999;
            const bowl = decay * (
              Math.sin(bowlPhase * 110) * 0.5 +
              Math.sin(bowlPhase * 220.5) * 0.25 +
              Math.sin(bowlPhase * 330.7) * 0.125
            );
            
            templeLeft[i] = bowl * 0.6;
            templeRight[i] = bowl * 0.4;
          } else {
            templeLeft[i] = 0;
            templeRight[i] = 0;
          }
        }
        this.soundscapeBuffers.temple = templeBuffer;
      }
      
      startBinauralBeats(type) {
        this.stop();
        this.binauralType = type;
        
        // Set frequencies based on brainwave type
        const { carrierFreq, beatFreq } = this.getFrequenciesForType(type);
        const leftFreq = carrierFreq;
        const rightFreq = carrierFreq + beatFreq;
        
        // Create oscillators
        const leftOsc = this.audioContext.createOscillator();
        leftOsc.type = 'sine';
        leftOsc.frequency.value = leftFreq;
        
        const rightOsc = this.audioContext.createOscillator();
        rightOsc.type = 'sine';
        rightOsc.frequency.value = rightFreq;
        
        // Create gain nodes
        const leftGain = this.audioContext.createGain();
        leftGain.gain.value = 0.1;
        
        const rightGain = this.audioContext.createGain();
        rightGain.gain.value = 0.1;
        
        // Create panners for 8D effect
        const leftPanner = this.audioContext.createStereoPanner();
        leftPanner.pan.value = -1;
        
        const rightPanner = this.audioContext.createStereoPanner();
        rightPanner.pan.value = 1;
        
        // Connect nodes
        leftOsc.connect(leftGain).connect(leftPanner).connect(this.merger, 0, 0);
        rightOsc.connect(rightGain).connect(rightPanner).connect(this.merger, 0, 1);
        
        // Start oscillators
        leftOsc.start();
        rightOsc.start();
        
        // Save references
        this.oscillators = [leftOsc, rightOsc];
        this.gainNodes = [leftGain, rightGain];
        this.panners = [leftPanner, rightPanner];
        
        this.isPlaying = true;
        this.lastPanUpdate = performance.now();
        
        // Start 8D panning effect
        this.updatePanning();
      }
      
      getFrequenciesForType(type) {
        const types = {
          theta: { carrierFreq: 150, beatFreq: 6 },  // 4-8Hz
          alpha: { carrierFreq: 200, beatFreq: 10 }, // 8-12Hz
          beta: { carrierFreq: 250, beatFreq: 18 },  // 12-30Hz
          gamma: { carrierFreq: 300, beatFreq: 40 }, // 30-100Hz
          delta: { carrierFreq: 120, beatFreq: 2 }   // 0.5-4Hz
        };
        
        return types[type] || types.theta;
      }
      
      playSoundscape(type) {
        if (type === 'none') {
          if (this.soundscape) {
            this.soundscape.stop();
            this.soundscape = null;
          }
          return;
        }
        
        const buffer = this.soundscapeBuffers[type];
        if (!buffer) return;
        
        if (this.soundscape) {
          this.soundscape.stop();
        }
        
        const source = this.audioContext.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        source.connect(this.merger);
        source.start();
        
        this.soundscape = source;
      }
      
      updatePanning() {
        if (!this.isPlaying) return;
        
        const now = performance.now();
        const deltaTime = now - this.lastPanUpdate;
        this.lastPanUpdate = now;
        
        // Update pan positions with smooth movement
        const panIncrement = this.panSpeed * deltaTime * this.panDirection;
        
        this.panners[0].pan.value = Math.sin(now * 0.001) * 0.8;
        this.panners[1].pan.value = Math.sin(now * 0.001 + Math.PI/2) * 0.8;
        
        // More complex 8D movement
        const leftPan = Math.sin(now * 0.0007) * 0.9;
        const rightPan = Math.cos(now * 0.0008) * 0.9;
        
        this.panners[0].pan.value = leftPan;
        this.panners[1].pan.value = rightPan;
        
        // Apply volume modulation based on pan position
        this.gainNodes[0].gain.value = 0.1 * (1 - leftPan * 0.5);
        this.gainNodes[1].gain.value = 0.1 * (1 - rightPan * 0.5);
        
        requestAnimationFrame(() => this.updatePanning());
      }
      
      getAudioData() {
        const bufferLength = this.analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        this.analyser.getByteFrequencyData(dataArray);
        return dataArray;
      }
      
      stop() {
        this.oscillators.forEach(osc => osc.stop());
        this.oscillators = [];
        this.gainNodes = [];
        this.panners = [];
        
        if (this.soundscape) {
          this.soundscape.stop();
          this.soundscape = null;
        }
        
        this.isPlaying = false;
      }
    }
    
    // Enhanced Visual Engine with full-screen effects
    class AdvancedVisualEngine {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.resize();
        this.particles = [];
        this.theme = 'nebula';
        this.visualType = 'particles';
        this.intensity = 5;
        this.isAnimating = false;
        this.audioData = new Uint8Array(10);
        this.lastFrameTime = 0;
        
        window.addEventListener('resize', () => this.resize());
      }
      
      resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.width = this.canvas.width;
        this.height = this.canvas.height;
        
        if (this.isAnimating) {
          this.initParticles();
        }
      }
      
      start(theme, visualType, intensity) {
        this.theme = theme;
        this.visualType = visualType;
        this.intensity = intensity;
        this.isAnimating = true;
        this.lastFrameTime = 0;
        
        this.initParticles();
        this.animate();
      }
      
      initParticles() {
        const particleCount = Math.floor((this.width * this.height) / 1000) * (this.intensity / 5);
        this.particles = [];
        
        for (let i = 0; i < particleCount; i++) {
          this.particles.push(this.createParticle());
        }
      }
      
      createParticle() {
        const types = {
          nebula: {
            x: Math.random() * this.width,
            y: Math.random() * this.height,
            size: Math.random() * 5 + 1,
            speedX: (Math.random() - 0.5) * (this.intensity * 0.2),
            speedY: (Math.random() - 0.5) * (this.intensity * 0.2),
            color: `hsla(${Math.random() * 60 + 200}, 80%, 60%, ${Math.random() * 0.5 + 0.3})`,
            life: Math.random() * 100,
            type: 'standard'
          },
          fluid: {
            x: Math.random() * this.width,
            y: Math.random() * this.height,
            size: Math.random() * 10 + 5,
            speedX: (Math.random() - 0.5) * (this.intensity * 0.1),
            speedY: (Math.random() - 0.5) * (this.intensity * 0.1),
            color: `hsla(${Math.random() * 120 + 180}, 80%, 50%, ${Math.random() * 0.3 + 0.2})`,
            life: 0,
            type: 'fluid'
          },
          particles: {
            x: Math.random() * this.width,
            y: Math.random() * this.height,
            size: Math.random() * 3 + 1,
            speedX: (Math.random() - 0.5) * (this.intensity * 0.3),
            speedY: (Math.random() - 0.5) * (this.intensity * 0.3),
            color: `hsla(${Math.random() * 360}, 100%, 70%, 0.8)`,
            life: Math.random() * 100,
            type: 'quantum'
          },
          fractal: {
            x: this.width / 2 + (Math.random() - 0.5) * 100,
            y: this.height / 2 + (Math.random() - 0.5) * 100,
            size: Math.random() * 2 + 1,
            speedX: (Math.random() - 0.5) * (this.intensity * 0.05),
            speedY: (Math.random() - 0.5) * (this.intensity * 0.05),
            color: `hsla(${Math.random() * 60 + 270}, 80%, 60%, 0.7)`,
            life: 0,
            type: 'fractal'
          }
        };
        
        return types[this.theme] || types.nebula;
      }
      
      animate() {
        if (!this.isAnimating) return;
        
        const now = performance.now();
        const deltaTime = now - this.lastFrameTime;
        this.lastFrameTime = now;
        
        this.clearCanvas();
        this.updateParticles(deltaTime);
        this.drawParticles();
        
        requestAnimationFrame(() => this.animate());
      }
      
      clearCanvas() {
        // Theme-based clearing
        switch (this.theme) {
          case 'fluid':
            this.ctx.fillStyle = 'rgba(5, 10, 20, 0.1)';
            break;
          case 'particles':
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            break;
          case 'fractal':
            this.ctx.fillStyle = 'rgba(10, 5, 20, 0.2)';
            break;
          default: // nebula
            this.ctx.fillStyle = 'rgba(0, 5, 15, 0.1)';
        }
        
        this.ctx.fillRect(0, 0, this.width, this.height);
      }
      
      updateParticles(deltaTime) {
        // Update based on audio data
        const audioScale = this.audioData ? (this.audioData[3] / 255) * 2 : 1;
        
        this.particles.forEach(particle => {
          // Move particle
          particle.x += particle.speedX * audioScale;
          particle.y += particle.speedY * audioScale;
          
          // Apply theme-specific behavior
          switch (particle.type) {
            case 'fluid':
              particle.size = 5 + Math.sin(particle.life * 0.05) * 5;
              particle.life += 0.1;
              break;
              
            case 'quantum':
              if (Math.random() < 0.01) {
                particle.speedX = (Math.random() - 0.5) * (this.intensity * 0.3);
                particle.speedY = (Math.random() - 0.5) * (this.intensity * 0.3);
              }
              break;
              
            case 'fractal':
              particle.x += (this.width/2 - particle.x) * 0.001;
              particle.y += (this.height/2 - particle.y) * 0.001;
              break;
          }
          
          // Wrap around edges
          if (particle.x < 0) particle.x = this.width;
          if (particle.x > this.width) particle.x = 0;
          if (particle.y < 0) particle.y = this.height;
          if (particle.y > this.height) particle.y = 0;
          
          // Random regeneration
          if (Math.random() < 0.002 * this.intensity) {
            const newParticle = this.createParticle();
            particle.x = newParticle.x;
            particle.y = newParticle.y;
          }
        });
      }
      
      drawParticles() {
        this.particles.forEach(particle => {
          this.ctx.beginPath();
          
          // Different rendering based on type
          switch (particle.type) {
            case 'fluid':
              const gradient = this.ctx.createRadialGradient(
                particle.x, particle.y, 0,
                particle.x, particle.y, particle.size
              );
              gradient.addColorStop(0, particle.color);
              gradient.addColorStop(1, 'rgba(0,0,0,0)');
              this.ctx.fillStyle = gradient;
              this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
              break;
              
            case 'quantum':
              this.ctx.fillStyle = particle.color;
              this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
              
              // Draw connection lines to nearby particles
              if (Math.random() < 0.3) {
                const closeParticles = this.particles.filter(p => {
                  const dx = p.x - particle.x;
                  const dy = p.y - particle.y;
                  return (dx * dx + dy * dy) < 10000; // 100px distance
                });
                
                closeParticles.forEach(p => {
                  this.ctx.moveTo(particle.x, particle.y);
                  this.ctx.lineTo(p.x, p.y);
                });
                
                this.ctx.strokeStyle = particle.color.replace('0.8', '0.2');
                this.ctx.lineWidth = 0.5;
                this.ctx.stroke();
              }
              break;
              
            case 'fractal':
              this.ctx.strokeStyle = particle.color;
              this.ctx.lineWidth = particle.size;
              
              // Draw connections to other particles
              const connections = Math.floor(3 * this.intensity / 5);
              for (let i = 0; i < connections; i++) {
                const randomParticle = this.particles[Math.floor(Math.random() * this.particles.length)];
                this.ctx.moveTo(particle.x, particle.y);
                this.ctx.lineTo(randomParticle.x, randomParticle.y);
              }
              this.ctx.stroke();
              break;
              
            default: // standard
              this.ctx.fillStyle = particle.color;
              this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
          }
          
          this.ctx.fill();
        });
      }
      
      updateAudioData(data) {
        this.audioData = data;
      }
      
      stop() {
        this.isAnimating = false;
        this.ctx.clearRect(0, 0, this.width, this.height);
      }
    }
    
    // Main App Class
    class NeuroFlux {
      constructor() {
        // DOM Elements
        this.elements = {
          app: document.getElementById('app'),
          wheel: document.getElementById('wheel'),
          wheelCenter: document.getElementById('wheel-center'),
          intensitySlider: document.getElementById('intensity-slider'),
          intensityValue: document.getElementById('intensity-value'),
          quickReliefBtn: document.getElementById('quick-relief'),
          moodSelector: document.getElementById('mood-selector'),
          activeSession: document.getElementById('active-session'),
          sessionTitle: document.getElementById('session-title'),
          sessionTimer: document.getElementById('session-timer'),
          binauralType: document.getElementById('binaural-type'),
          soundscape: document.getElementById('soundscape'),
          visualTheme: document.getElementById('visual-theme'),
          visualIntensity: document.getElementById('visual-intensity'),
          pauseBtn: document.getElementById('pause-btn'),
          stopBtn: document.getElementById('stop-btn'),
          presetBtns: document.querySelectorAll('.preset-btn'),
          journalEntry: document.getElementById('journal-entry'),
          saveJournalBtn: document.getElementById('save-journal'),
          progressChart: document.getElementById('progress-chart'),
          historyList: document.getElementById('history-list'),
          clearHistoryBtn: document.getElementById('clear-history'),
          tabs: document.querySelectorAll('.tab'),
          tabContents: document.querySelectorAll('.tab-content'),
          visuals: document.getElementById('visuals'),
          audioBars: document.getElementById('audio-bars').children,
          biofeedbackBtn: document.getElementById('biofeedback-btn'),
          breathFeedback: document.getElementById('breath-feedback'),
          morningReminder: document.getElementById('morning-reminder'),
          eveningReminder: document.getElementById('evening-reminder'),
          morningTime: document.getElementById('morning-time'),
          eveningTime: document.getElementById('evening-time'),
          saveSettingsBtn: document.getElementById('save-settings'),
          fullscreenBtn: document.getElementById('fullscreen-btn')
        };
        
        // App State
        this.state = {
          currentMood: null,
          currentIntensity: 5,
          sessionActive: false,
          sessionPaused: false,
          sessionEndTime: 0,
          remainingTime: 0,
          timerInterval: null,
          audioEngine: null,
          visualEngine: null,
          journalEntries: [],
          sessionHistory: [],
          reminders: {},
          biofeedbackActive: false,
          lastBreathTime: 0,
          breathRate: 0,
          fullscreen: false
        };
        
        // Initialize
        this.initAudioEngine();
        this.initVisualEngine();
        this.loadData();
        this.setupEventListeners();
        this.checkReminders();
        setInterval(() => this.checkReminders(), 60000); // Check every minute
        
        // Service Worker Registration for offline use
        if ('serviceWorker' in navigator) {
          window.addEventListener('load', () => {
            navigator.serviceWorker.register('sw.js').then(registration => {
              console.log('ServiceWorker registration successful');
            }).catch(err => {
              console.log('ServiceWorker registration failed: ', err);
            });
          });
        }
      }
      
      initAudioEngine() {
        this.state.audioEngine = new AdvancedAudioEngine();
      }
      
      initVisualEngine() {
        const canvas = this.elements.visuals;
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        this.state.visualEngine = new AdvancedVisualEngine(canvas);
      }
      
      loadData() {
        // Load journal entries
        const journalData = localStorage.getItem('neuroflux_journal');
        if (journalData) {
          this.state.journalEntries = JSON.parse(journalData);
        }
        
        // Load session history
        const historyData = localStorage.getItem('neuroflux_history');
        if (historyData) {
          this.state.sessionHistory = JSON.parse(historyData);
          this.renderHistory();
        }
        
        // Load settings
        const settingsData = localStorage.getItem('neuroflux_settings');
        if (settingsData) {
          const settings = JSON.parse(settingsData);
          this.state.reminders = settings.reminders || {};
          
          if (this.state.reminders.morning) {
            this.elements.morningReminder.checked = true;
            this.elements.morningTime.value = this.state.reminders.morning.time;
          }
          
          if (this.state.reminders.evening) {
            this.elements.eveningReminder.checked = true;
            this.elements.eveningTime.value = this.state.reminders.evening.time;
          }
        }
        
        // Initialize chart
        this.renderProgressChart();
      }
      
      saveData() {
        localStorage.setItem('neuroflux_journal', JSON.stringify(this.state.journalEntries));
        localStorage.setItem('neuroflux_history', JSON.stringify(this.state.sessionHistory));
        
        const settings = {
          reminders: this.state.reminders
        };
        localStorage.setItem('neuroflux_settings', JSON.stringify(settings));
      }
      
      setupEventListeners() {
        // Mood wheel selection
        this.elements.wheelCenter.addEventListener('click', () => {
          if (this.state.currentMood) {
            this.startSession(this.state.currentMood, this.state.currentIntensity);
          }
        });
        
        // Wheel sections
        const wheelSections = document.querySelectorAll('.wheel-section');
        wheelSections.forEach(section => {
          section.addEventListener('click', (e) => {
            e.stopPropagation();
            this.state.currentMood = section.dataset.mood;
            this.elements.wheelCenter.textContent = this.capitalizeFirstLetter(this.state.currentMood);
          });
        });
        
        // Intensity slider
        this.elements.intensitySlider.addEventListener('input', (e) => {
          this.state.currentIntensity = parseInt(e.target.value);
          this.elements.intensityValue.textContent = this.state.currentIntensity;
        });
        
        // Quick relief button
        this.elements.quickReliefBtn.addEventListener('click', () => {
          if (this.state.currentMood) {
            this.startSession(this.state.currentMood, this.state.currentIntensity, 5 * 60);
          } else {
            this.showNotification('Please select a mood first');
          }
        });
        
        // Preset buttons
        this.elements.presetBtns.forEach(btn => {
          btn.addEventListener('click', () => {
            const preset = btn.dataset.preset;
            this.startPresetSession(preset);
          });
        });
        
        // Audio controls
        this.elements.binauralType.addEventListener('change', () => {
          if (this.state.sessionActive) {
            this.state.audioEngine.startBinauralBeats(this.elements.binauralType.value);
          }
        });
        
        this.elements.soundscape.addEventListener('change', () => {
          if (this.state.sessionActive) {
            this.state.audioEngine.playSoundscape(this.elements.soundscape.value);
          }
        });
        
        // Visual controls
        this.elements.visualTheme.addEventListener('change', () => {
          if (this.state.sessionActive) {
            this.state.visualEngine.start(
              this.elements.visualTheme.value,
              'particles',
              parseInt(this.elements.visualIntensity.value)
            );
          }
        });
        
        this.elements.visualIntensity.addEventListener('input', () => {
          if (this.state.sessionActive) {
            this.state.visualEngine.intensity = parseInt(this.elements.visualIntensity.value);
          }
        });
        
        // Session controls
        this.elements.pauseBtn.addEventListener('click', () => {
          if (this.state.sessionPaused) {
            this.resumeSession();
          } else {
            this.pauseSession();
          }
        });
        
        this.elements.stopBtn.addEventListener('click', () => {
          this.endSession();
        });
        
        // Journal and history
        this.elements.saveJournalBtn.addEventListener('click', () => {
          this.saveJournalEntry();
        });
        
        this.elements.clearHistoryBtn.addEventListener('click', () => {
          if (confirm('Are you sure you want to clear all history?')) {
            this.state.sessionHistory = [];
            this.state.journalEntries = [];
            localStorage.removeItem('neuroflux_history');
            localStorage.removeItem('neuroflux_journal');
            this.renderHistory();
            this.renderProgressChart();
          }
        });
        
        // Tabs
        this.elements.tabs.forEach(tab => {
          tab.addEventListener('click', () => {
            const tabId = tab.dataset.tab;
            this.switchTab(tabId);
          });
        });
        
        // Biofeedback
        this.elements.biofeedbackBtn.addEventListener('click', () => {
          if (!this.state.biofeedbackActive) {
            this.startBiofeedback();
          } else {
            this.stopBiofeedback();
          }
        });
        
        // Settings
        this.elements.saveSettingsBtn.addEventListener('click', () => {
          this.saveSettings();
        });
        
        // Fullscreen
        this.elements.fullscreenBtn.addEventListener('click', () => {
          this.toggleFullscreen();
        });
        
        // Window resize
        window.addEventListener('resize', () => {
          this.elements.visuals.width = window.innerWidth;
          this.elements.visuals.height = window.innerHeight;
          if (this.state.visualEngine) {
            this.state.visualEngine.resize();
          }
        });
        
        // Start animation loop for audio visualization
        this.startAnimationLoop();
      }
      
      startAnimationLoop() {
        const update = () => {
          // Update audio visualization
          if (this.state.audioEngine && this.state.sessionActive) {
            const audioData = this.state.audioEngine.getAudioData();
            if (audioData) {
              for (let i = 0; i < this.elements.audioBars.length; i++) {
                const height = (audioData[i] / 255) * 60;
                this.elements.audioBars[i].style.height = `${height}px`;
              }
              
              // Send audio data to visual engine
              this.state.visualEngine.updateAudioData(audioData);
            }
          }
          
          requestAnimationFrame(update);
        };
        
        requestAnimationFrame(update);
      }
      
      toggleFullscreen() {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen().catch(err => {
            console.error('Error attempting to enable fullscreen:', err);
          });
          this.elements.fullscreenBtn.textContent = '⤡';
          this.state.fullscreen = true;
        } else {
          document.exitFullscreen();
          this.elements.fullscreenBtn.textContent = '⤢';
          this.state.fullscreen = false;
        }
      }
      
      switchTab(tabId) {
        // Update active tab
        this.elements.tabs.forEach(tab => {
          if (tab.dataset.tab === tabId) {
            tab.classList.add('active');
          } else {
            tab.classList.remove('active');
          }
        });
        
        // Update active content
        this.elements.tabContents.forEach(content => {
          if (content.id === `${tabId}-tab`) {
            content.classList.add('active');
          } else {
            content.classList.remove('active');
          }
        });
        
        // Special handling for progress tab
        if (tabId === 'progress') {
          setTimeout(() => this.renderProgressChart(), 100);
        }
      }
      
      startSession(mood, intensity, duration = null) {
        // Default duration based on intensity (1-10 maps to 3-15 minutes)
        const minutes = duration ? duration / 60 : 3 + (intensity * 1.2);
        const sessionDuration = duration || Math.round(minutes * 60);
        
        // Set session end time (current time + duration in seconds)
        this.state.sessionEndTime = Date.now() + (sessionDuration * 1000);
        this.state.remainingTime = sessionDuration;
        this.state.sessionActive = true;
        this.state.sessionPaused = false;
        
        // Update UI
        this.elements.moodSelector.classList.add('hidden');
        this.elements.activeSession.classList.remove('hidden');
        this.elements.sessionTitle.textContent = `${this.capitalizeFirstLetter(mood)} Relief Session`;
        this.updateTimerDisplay();
        
        // Start timer
        this.state.timerInterval = setInterval(() => this.updateTimer(), 1000);
        
        // Start audio based on mood and intensity
        const frequencies = this.getFrequenciesForMood(mood, intensity);
        this.state.audioEngine.startBinauralBeats(this.elements.binauralType.value);
        this.state.audioEngine.playSoundscape(this.elements.soundscape.value);
        
        // Start visuals based on mood and theme
        const visualParams = this.getVisualParamsForMood(mood, intensity);
        this.state.visualEngine.start(
          this.elements.visualTheme.value,
          'particles',
          parseInt(this.elements.visualIntensity.value)
        );
        
        // Add quick pulse animation to quick relief button
        this.elements.quickReliefBtn.classList.add('pulse');
      }
      
      startPresetSession(preset) {
        const presets = {
          panic: {
            mood: 'anxiety',
            intensity: 8,
            duration: 5 * 60,
            binauralType: 'theta',
            soundscape: 'cosmic',
            visualTheme: 'nebula',
            visualIntensity: 7
          },
          focus: {
            mood: 'fatigue',
            intensity: 6,
            duration: 25 * 60,
            binauralType: 'beta',
            soundscape: 'none',
            visualTheme: 'particles',
            visualIntensity: 5
          },
          creative: {
            mood: 'fatigue',
            intensity: 5,
            duration: 45 * 60,
            binauralType: 'alpha',
            soundscape: 'forest',
            visualTheme: 'fluid',
            visualIntensity: 6
          },
          grief: {
            mood: 'sadness',
            intensity: 7,
            duration: 15 * 60,
            binauralType: 'delta',
            soundscape: 'temple',
            visualTheme: 'fractal',
            visualIntensity: 4
          },
          sleep: {
            mood: 'fatigue',
            intensity: 4,
            duration: 20 * 60,
            binauralType: 'delta',
            soundscape: 'ocean',
            visualTheme: 'nebula',
            visualIntensity: 3
          }
        };
        
        const presetConfig = presets[preset];
        if (!presetConfig) return;
        
        // Set UI to match preset
        this.elements.binauralType.value = presetConfig.binauralType;
        this.elements.soundscape.value = presetConfig.soundscape;
        this.elements.visualTheme.value = presetConfig.visualTheme;
        this.elements.visualIntensity.value = presetConfig.visualIntensity;
        
        // Set session end time
        this.state.sessionEndTime = Date.now() + (presetConfig.duration * 1000);
        this.state.remainingTime = presetConfig.duration;
        this.state.sessionActive = true;
        this.state.sessionPaused = false;
        
        // Update UI
        this.elements.moodSelector.classList.add('hidden');
        this.elements.activeSession.classList.remove('hidden');
        this.elements.sessionTitle.textContent = `${this.capitalizeFirstLetter(presetConfig.mood)} (${this.capitalizeFirstLetter(preset)})`;
        this.updateTimerDisplay();
        
        // Start timer
        this.state.timerInterval = setInterval(() => this.updateTimer(), 1000);
        
        // Start audio
        this.state.audioEngine.startBinauralBeats(presetConfig.binauralType);
        this.state.audioEngine.playSoundscape(presetConfig.soundscape);
        
        // Start visuals
        this.state.visualEngine.start(
          presetConfig.visualTheme,
          'particles',
          presetConfig.visualIntensity
        );
        
        // Add quick pulse animation to quick relief button
        this.elements.quickReliefBtn.classList.add('pulse');
      }
      
      pauseSession() {
        if (!this.state.sessionActive || this.state.sessionPaused) return;
        
        clearInterval(this.state.timerInterval);
        this.state.sessionPaused = true;
        this.state.audioEngine.stop();
        this.state.visualEngine.stop();
        this.elements.pauseBtn.textContent = 'Resume';
      }
      
      resumeSession() {
        if (!this.state.sessionActive || !this.state.sessionPaused) return;
        
        // Update end time based on remaining time
        this.state.sessionEndTime = Date.now() + (this.state.remainingTime * 1000);
        this.state.timerInterval = setInterval(() => this.updateTimer(), 1000);
        this.state.sessionPaused = false;
        
        // Restart audio and visuals
        this.state.audioEngine.startBinauralBeats(this.elements.binauralType.value);
        this.state.audioEngine.playSoundscape(this.elements.soundscape.value);
        this.state.visualEngine.start(
          this.elements.visualTheme.value,
          'particles',
          parseInt(this.elements.visualIntensity.value)
        );
        
        this.elements.pauseBtn.textContent = 'Pause';
      }
      
      endSession() {
        if (!this.state.sessionActive) return;
        
        clearInterval(this.state.timerInterval);
        this.state.sessionActive = false;
        this.state.sessionPaused = false;
        
        // Stop audio and visuals
        this.state.audioEngine.stop();
        this.state.visualEngine.stop();
        
        // Update UI
        this.elements.moodSelector.classList.remove('hidden');
        this.elements.activeSession.classList.add('hidden');
        this.elements.quickReliefBtn.classList.remove('pulse');
        this.elements.pauseBtn.textContent = 'Pause';
        
        // Save session to history
        this.saveSessionToHistory();
        
        // Switch to journal tab
        this.switchTab('journal');
      }
      
      updateTimer() {
        if (this.state.sessionPaused) return;
        
        const now = Date.now();
        this.state.remainingTime = Math.max(0, Math.floor((this.state.sessionEndTime - now) / 1000));
        
        this.updateTimerDisplay();
        
        if (this.state.remainingTime <= 0) {
          this.endSession();
        }
      }
      
      updateTimerDisplay() {
        const minutes = Math.floor(this.state.remainingTime / 60);
        const seconds = this.state.remainingTime % 60;
        this.elements.sessionTimer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
      
      getFrequenciesForMood(mood, intensity) {
        // Base frequencies adjusted by intensity
        const intensityFactor = intensity / 10;
        
        const moodFrequencies = {
          stress: { baseCarrier: 200, baseBeat: 10 },
          anxiety: { baseCarrier: 180, baseBeat: 6 },
          sadness: { baseCarrier: 160, baseBeat: 4 },
          anger: { baseCarrier: 220, baseBeat: 14 },
          fatigue: { baseCarrier: 150, baseBeat: 2 }
        };
        
        const base = moodFrequencies[mood] || moodFrequencies.stress;
        const carrier = base.baseCarrier + (30 * intensityFactor);
        const beat = base.baseBeat + (4 * intensityFactor);
        
        return { carrier, beat };
      }
      
      getVisualParamsForMood(mood, intensity) {
        const intensityFactor = intensity / 10;
        
        const moodVisuals = {
          stress: { type: 'flow', baseSpeed: 0.8, color: '#ff6b6b' },
          anxiety: { type: 'particles', baseSpeed: 1.2, color: '#ff9e2d' },
          sadness: { type: 'ink', baseSpeed: 0.3, color: '#4cc9f0' },
          anger: { type: 'fractal', baseSpeed: 1.5, color: '#f72585' },
          fatigue: { type: 'particles', baseSpeed: 0.2, color: '#7209b7' }
        };
        
        const base = moodVisuals[mood] || moodVisuals.stress;
        const speed = base.baseSpeed * (0.5 + intensityFactor);
        
        return { type: base.type, speed, color: base.color };
      }
      
      saveSessionToHistory() {
        if (!this.state.currentMood) return;
        
        const session = {
          date: new Date().toISOString(),
          mood: this.state.currentMood,
          intensity: this.state.currentIntensity,
          duration: this.state.remainingTime
        };
        
        this.state.sessionHistory.unshift(session);
        if (this.state.sessionHistory.length > 100) {
          this.state.sessionHistory.pop();
        }
        
        this.saveData();
        this.renderHistory();
        this.renderProgressChart();
      }
      
      saveJournalEntry() {
        const entry = {
          date: new Date().toISOString(),
          mood: this.state.currentMood,
          text: this.elements.journalEntry.value
        };
        
        if (entry.text.trim()) {
          this.state.journalEntries.unshift(entry);
          if (this.state.journalEntries.length > 50) {
            this.state.journalEntries.pop();
          }
          
          this.saveData();
          this.elements.journalEntry.value = '';
          this.showNotification('Journal entry saved');
        }
      }
      
      renderHistory() {
        const historyList = this.elements.historyList;
        historyList.innerHTML = '';
        
        if (this.state.sessionHistory.length === 0) {
          historyList.innerHTML = '<p>No session history yet</p>';
          return;
        }
        
        this.state.sessionHistory.forEach(session => {
          const date = new Date(session.date);
          const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          
          const item = document.createElement('div');
          item.className = 'history-item';
          item.innerHTML = `
            <div>
              <span class="history-item-mood">${this.capitalizeFirstLetter(session.mood)}</span>
              <span> - Intensity ${session.intensity}</span>
            </div>
            <div class="history-item-date">${dateStr}</div>
          `;
          
          historyList.appendChild(item);
        });
      }
      
      renderProgressChart() {
        const ctx = this.elements.progressChart.getContext('2d');
        
        // Group by day and calculate average intensity per mood
        const moodData = {
          stress: [],
          anxiety: [],
          sadness: [],
          anger: [],
          fatigue: []
        };
        
        const dates = [];
        const dataMap = {};
        
        // Process last 30 days of data
        const now = new Date();
        for (let i = 29; i >= 0; i--) {
          const date = new Date(now);
          date.setDate(date.getDate() - i);
          const dateKey = date.toISOString().split('T')[0];
          dates.push(dateKey);
          dataMap[dateKey] = {
            stress: { sum: 0, count: 0 },
            anxiety: { sum: 0, count: 0 },
            sadness: { sum: 0, count: 0 },
            anger: { sum: 0, count: 0 },
            fatigue: { sum: 0, count: 0 }
          };
        }
        
        // Populate data
        this.state.sessionHistory.forEach(session => {
          const sessionDate = new Date(session.date);
          const dateKey = sessionDate.toISOString().split('T')[0];
          
          if (dataMap[dateKey] && dataMap[dateKey][session.mood]) {
            dataMap[dateKey][session.mood].sum += session.intensity;
            dataMap[dateKey][session.mood].count++;
          }
        });
        
        // Calculate averages
        dates.forEach(date => {
          Object.keys(moodData).forEach(mood => {
            const data = dataMap[date][mood];
            const avg = data.count > 0 ? (data.sum / data.count) : null;
            moodData[mood].push(avg);
          });
        });
        
        // Create chart
        if (window.Chart) {
          // Destroy previous chart if it exists
          if (this.state.progressChart) {
            this.state.progressChart.destroy();
          }
          
          this.state.progressChart = new window.Chart(ctx, {
            type: 'line',
            data: {
              labels: dates.map(date => date.split('-')[1] + '/' + date.split('-')[2]),
              datasets: [
                {
                  label: 'Stress',
                  data: moodData.stress,
                  borderColor: '#ff6b6b',
                  backgroundColor: 'rgba(255, 107, 107, 0.1)',
                  tension: 0.3,
                  spanGaps: true
                },
                {
                  label: 'Anxiety',
                  data: moodData.anxiety,
                  borderColor: '#ff9e2d',
                  backgroundColor: 'rgba(255, 158, 45, 0.1)',
                  tension: 0.3,
                  spanGaps: true
                },
                {
                  label: 'Sadness',
                  data: moodData.sadness,
                  borderColor: '#4cc9f0',
                  backgroundColor: 'rgba(76, 201, 240, 0.1)',
                  tension: 0.3,
                  spanGaps: true
                },
                {
                  label: 'Anger',
                  data: moodData.anger,
                  borderColor: '#f72585',
                  backgroundColor: 'rgba(247, 37, 133, 0.1)',
                  tension: 0.3,
                  spanGaps: true
                },
                {
                  label: 'Fatigue',
                  data: moodData.fatigue,
                  borderColor: '#7209b7',
                  backgroundColor: 'rgba(114, 9, 183, 0.1)',
                  tension: 0.3,
                  spanGaps: true
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  beginAtZero: true,
                  max: 10,
                  ticks: {
                    stepSize: 2
                  }
                }
              },
              plugins: {
                legend: {
                  position: 'top',
                  labels: {
                    color: '#f8f9fa'
                  }
                },
                tooltip: {
                  mode: 'index',
                  intersect: false
                }
              },
              elements: {
                point: {
                  radius: 3,
                  hoverRadius: 5
                }
              }
            }
          });
        }
      }
      
      startBiofeedback() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          this.showNotification('Biofeedback not supported in your browser');
          return;
        }
        
        this.state.biofeedbackActive = true;
        this.elements.biofeedbackBtn.textContent = 'Disable Biofeedback';
        this.elements.breathFeedback.textContent = 'Listening for breath...';
        
        navigator.mediaDevices.getUserMedia({ audio: true, video: false })
          .then(stream => {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const analyser = audioContext.createAnalyser();
            const microphone = audioContext.createMediaStreamSource(stream);
            microphone.connect(analyser);
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            let lastBreathTime = 0;
            let breathCount = 0;
            let lastVolume = 0;
            let breathDetected = false;
            
            const detectBreath = () => {
              if (!this.state.biofeedbackActive) return;
              
              analyser.getByteTimeDomainData(dataArray);
              
              let sum = 0;
              for (let i = 0; i < bufferLength; i++) {
                sum += Math.abs(dataArray[i] - 128);
              }
              
              const volume = sum / bufferLength;
              
              // Detect breath (simple threshold-based detection)
              if (volume > 10 && !breathDetected && volume > lastVolume * 1.5) {
                breathDetected = true;
                const now = Date.now();
                
                if (lastBreathTime > 0) {
                  const breathInterval = (now - lastBreathTime) / 1000;
                  this.state.breathRate = 60 / breathInterval;
                  
                  this.elements.breathFeedback.innerHTML = `
                    Breath rate: <strong>${this.state.breathRate.toFixed(1)} breaths/min</strong>
                    <div style="margin-top: 0.5rem; font-size: 0.8rem;">
                      ${this.getBreathFeedback(this.state.breathRate)}
                    </div>
                  `;
                }
                
                lastBreathTime = now;
                breathCount++;
              } else if (volume < 5) {
                breathDetected = false;
              }
              
              lastVolume = volume;
              requestAnimationFrame(detectBreath);
            };
            
            detectBreath();
            
            // Save the stream and analyser to stop later
            this.state.biofeedbackStream = stream;
            this.state.biofeedbackAnalyser = analyser;
          })
          .catch(err => {
            console.error('Error accessing microphone:', err);
            this.showNotification('Microphone access denied');
            this.stopBiofeedback();
          });
      }
      
      stopBiofeedback() {
        this.state.biofeedbackActive = false;
        this.elements.biofeedbackBtn.textContent = 'Enable Biofeedback';
        this.elements.breathFeedback.textContent = '';
        
        if (this.state.biofeedbackStream) {
          this.state.biofeedbackStream.getTracks().forEach(track => track.stop());
        }
      }
      
      getBreathFeedback(rate) {
        if (rate > 20) return 'Your breathing is fast. Try slowing down to 6-8 breaths per minute for relaxation.';
        if (rate > 12) return 'Your breathing is normal. Try slowing to 6 breaths per minute for deeper relaxation.';
        if (rate > 6) return 'Good slow breathing. This helps activate your parasympathetic nervous system.';
        return 'Very slow breathing. Excellent for deep meditation and relaxation.';
      }
      
      saveSettings() {
        this.state.reminders = {};
        
        if (this.elements.morningReminder.checked) {
          this.state.reminders.morning = {
            enabled: true,
            time: this.elements.morningTime.value
          };
        }
        
        if (this.elements.eveningReminder.checked) {
          this.state.reminders.evening = {
            enabled: true,
            time: this.elements.eveningTime.value
          };
        }
        
        this.saveData();
        this.showNotification('Settings saved');
        this.checkReminders();
      }
      
      checkReminders() {
        if (!('Notification' in window)) return;
        
        if (Notification.permission !== 'granted') {
          Notification.requestPermission();
          return;
        }
        
        const now = new Date();
        const currentHours = now.getHours();
        const currentMinutes = now.getMinutes();
        const currentTime = `${currentHours.toString().padStart(2, '0')}:${currentMinutes.toString().padStart(2, '0')}`;
        
        // Check morning reminder
        if (this.state.reminders.morning && this.state.reminders.morning.enabled) {
          if (currentTime === this.state.reminders.morning.time) {
            this.showNotification('🌞 Morning Reset Time', {
              body: 'Start your day with a calming NeuroFlux session'
            });
          }
        }
        
        // Check evening reminder
        if (this.state.reminders.evening && this.state.reminders.evening.enabled) {
          if (currentTime === this.state.reminders.evening.time) {
            this.showNotification('🌙 Evening Wind Down', {
              body: 'Release the day\'s stress with a NeuroFlux session'
            });
          }
        }
      }
      
      showNotification(title, options = {}) {
        if (!('Notification' in window)) return;
        
        if (Notification.permission === 'granted') {
          new Notification(title, options);
        } else if (Notification.permission !== 'denied') {
          Notification.requestPermission().then(permission => {
            if (permission === 'granted') {
              new Notification(title, options);
            }
          });
        }
      }
      
      capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
      }
    }
    
    // Embedded Chart.js (minified and modified to work inline)
    // This is a heavily simplified version of Chart.js for our needs
    (function() {
      if (typeof window.Chart === 'undefined') {
        window.Chart = function(ctx) {
          const gradients = {};
          
          function createGradient(ctx, area, color) {
            const gradient = ctx.createLinearGradient(0, area.bottom, 0, area.top);
            gradient.addColorStop(0, color.replace(')', ', 0)').replace('rgb', 'rgba'));
            gradient.addColorStop(1, color);
            return gradient;
          }
          
          return {
            config: null,
            data: null,
            destroy: function() {},
            
            update: function() {
              if (!this.config || !this.data) return;
              
              const {data, options} = this.config;
              const {datasets, labels} = data;
              const area = {
                top: 0,
                bottom: ctx.canvas.height,
                left: 0,
                right: ctx.canvas.width
              };
              
              // Clear canvas
              ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
              
              // Draw grid
              if (options.scales && options.scales.y) {
                const yScale = options.scales.y;
                const yRange = yScale.max - yScale.min;
                const step = yScale.ticks.stepSize || (yRange / 5);
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                for (let y = yScale.min; y <= yScale.max; y += step) {
                  const yPos = area.bottom - ((y - yScale.min) / yRange) * (area.bottom - area.top);
                  ctx.moveTo(area.left, yPos);
                  ctx.lineTo(area.right, yPos);
                }
                ctx.stroke();
              }
              
              // Draw datasets
              datasets.forEach((dataset, i) => {
                if (!gradients[i]) {
                  gradients[i] = createGradient(ctx, area, dataset.borderColor);
                }
                
                ctx.strokeStyle = gradients[i];
                ctx.fillStyle = dataset.backgroundColor;
                ctx.lineWidth = dataset.borderWidth || 2;
                
                const xStep = (area.right - area.left) / (labels.length - 1);
                const yRange = options.scales.y.max - options.scales.y.min;
                
                ctx.beginPath();
                
                dataset.data.forEach((value, j) => {
                  if (value === null) return;
                  
                  const x = area.left + (j * xStep);
                  const y = area.bottom - ((value - options.scales.y.min) / yRange) * (area.bottom - area.top);
                  
                  if (j === 0) {
                    ctx.moveTo(x, y);
                  } else {
                    ctx.lineTo(x, y);
                  }
                  
                  // Draw point
                  if (options.elements && options.elements.point && options.elements.point.radius > 0) {
                    ctx.beginPath();
                    ctx.arc(x, y, options.elements.point.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                  }
                });
                
                ctx.stroke();
              });
            }
          };
        };
      }
    })();
    
    // Initialize the app when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      const app = new NeuroFlux();
    });
  </script>
</body>
</html>
